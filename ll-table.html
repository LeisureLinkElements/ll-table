<!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="../polymer/polymer.html">

<link rel="import" href="../ll-theme/ll-theme.html">
<link rel="import" href="../ll-theme/shared-styles.html">

<script type="application/javascript" src="../lodash/lodash.js"></script>


<!--
Data-driven, table-less table generator with static or configuration-generated cell content, event-firing, column-wide repeating elements, and configurable item ID collection.

Example:

    <ll-table></ll-table>

### Features:
- **Configuration-driven:** Generates and updates entire table from a single json object. Dynamic insertion and deletion of individual rows is not supported.
- **Static or configuration-generated cell content:** Table cell content can be simple text or configuration-generated html elements.
- **Configuration-generated elements with event firing:** Generate any html element within a cell by setting an html tag and optional attributes, class list, inner-html, and list of event in/out pairs. The element listens for the "in" event and fires the corresponding "out" event with a data object containing the either the item ID only, or an object containing the event's configuration, and all element attributes (including a pseudo 'checked' attribute for checkboxes). Currently, only single, non-nested elements are supported.
- **Column-wide repeating content:** Populate an entire column of cells with the same static content or generated element by defining it in the column's configuration.
- **Column-wide item selection UI:** When a column definition contains an itemSelector node, the entire column of cells is populated with a UI corresponding to the itemSelector.type. The "selectedItemIds" array property reflects which items are selected. For example, if the 'assoc' column definition contains the node itemSelector: {type: 'checkbox'}, then a checkbox will appear in each cell of the column. Optionally, you may indicate which checkboxes are initially checked by setting the value of the 'assoc' key to true in the cfg.items[..].cells objects. Currently, only simple checkboxes are supported, but any other type of UI could be implemented.
- **Table-less markup:** Table is built with divs and css, not a table element.
- **Optional column headers:** To show column header row, include a 'label' node in at least one column definition.
- **DEV mode:** Set 'dev' attribute to true to output debugging messages to console.

@demo
-->
<dom-module id="ll-table">

    <style include="shared-styles"></style>

    <template>
        <div class="table">
            <template is="dom-if" if="{{hasHeaders}}">
                <div class="table-header">
                    <div class="table-row">
                        <template is="dom-repeat" items="[[cfg.colVals]]">
                            <div class="table-cell">[[item.label]]</div>
                        </template>
                    </div>
                </div>
            </template>
            <div class="table-body">
                <template is="dom-repeat" id="tableItems" items="[[cfg.items]]">
                    <div class="table-row">
                        <template is="dom-repeat" items="[[item.cellVals]]" as="cell">
                            <div class="table-cell" id="[[cell.id]]">
                                <template is="dom-if" if="{{cell.html}}">[[cell.html]]</template>
                                <template is="dom-if" if="{{cell.itemSelector.checkbox}}"><input type="checkbox" on-change="_toggleItemSelection"></template>
                            </div>
                        </template>
                    </div>
                </template>
                <array-selector id="itemSelector" items="{{cfg.items}}" selected="{{selectedItems}}" multi toggle></array-selector>
            </div>
        </div>
    </template>

</dom-module>

<script>

    Polymer({

        is: 'll-table',

        properties: {
            // Currently used only in dev mode debugging messages.
            name: {
                type: String,
                value: 'll-table'
            },
            // IDs of selected items.
            selectedItemIds: {
                type: Array,
                readOnly: true,
                notify: true,
                value: function() {
                    return [];
                }
            },
            // Set to true to activate dev mode to output debugging messages to console.
            dev: Boolean
        },

        // Element Lifecycle

        ready: function () {
            this._doFire('ll-table-ready');
        },

        attached: function() {
            this._doFire('ll-table-attached');
            this._addDynamicContentAfterTemplateCompletion();
        },

        // Element Behavior

        /**
         * Sets table configuration and data.
         * @param {object} cfg
         */
        setConfig: function(cfg) {
            if(!this.isValidConfig(cfg)) {
                return false;
            }
            this.cfg = _.cloneDeep(cfg);

            this._log('setConfig called with', cfg);

            var _this = this, cellContent, itemSelectorCfg;

            // If content key is set in any column config,
            // copy the content config to each cell config in the column.
            this.hasHeaders = false;
            _.forEach(this.cfg.cols, function (col, colName) {
                if(_.isString(col.label)) {
                    _this.hasHeaders = true;
                }
                _this.cfg.items.forEach(function (item, itemNum) {
                    if (_.isObject(col.content)) {
                        if(col.content.itemSelector) {
                            itemSelectorCfg = {};
                            itemSelectorCfg[col.content.itemSelector.type] = true;
                            cellContent = {
                                itemSelector: itemSelectorCfg
                            };
                        } else {
                            cellContent = _.cloneDeep(col.content);
                        }
                        _this.cfg.items[itemNum].cells[colName] = cellContent;
                    }
                });
            });

            if(this.hasHeaders) {
                this.cfg.colVals = _.values(this.cfg.cols); // For template
            }

            // Assign an id to each cell, converting cells with just string content to objects:
            this.cfg.items.forEach(function (item, itemNum) {
                _.forEach(item.cells, function (cell, colName) {
                    if (!_.isObject(cell)) {
                        _this.cfg.items[itemNum].cells[colName] = {html: _(cell).toString()};
                    }
                    _this.lastCellId = _this._getCellId(item.id, colName);
                    _this.cfg.items[itemNum].cells[colName].id = _this.lastCellId;
                });
                _this.cfg.items[itemNum].cellVals = _.values(_this.cfg.items[itemNum].cells); // For template
            });
            this._log('setConfig converted config to', this.cfg);
            return true;
        },

        _addDynamicContentAfterTemplateCompletion: function() {
            var _this = this;
            _this._log('waiting for last table cell to be created...');
            this.dynamicContentWaiter = window.setInterval(function() {
                if(window.document.querySelector('#'+_this.lastCellId) !== null) {
                    _this._log('last table cell #'+_this.lastCellId+' created');
                    _this._addDynamicContent();
                }
            },20);
        },

        /**
         * Returns array of item ids.
         * @param {string} column
         */
        _getSelectedItemIds: function() {
            var ids = [];
            if(_.isArray(this.selectedItems)) {
                this.selectedItems.forEach(function(item) {
                    ids.push(item.id);
                });
            }
            return ids;
        },

        /**
         * Returns true if cfg is valid configuration.
         * @param {object} cfg
         */
        isValidConfig: function(cfg) {
            return _.isObject(cfg) && _.isArray(cfg.items);
        },

        /**
         * Returns true if cfg is valid configuration and has one or more items.
         * @param {object} cfg
         */
        hasItems: function(cfg) {
            return this.isValidConfig(cfg) && cfg.items.length;
        },

        _addDynamicContent: function() {

            window.clearInterval(this.dynamicContentWaiter);

            if(this.isValidConfig(this.cfg)) {

                this._log('_addDynamicContent proceeding');

                var
                    _this = this,
                    spec,
                    tableCell,
                    cellId,
                    polyment,
                    eventInfo;

                this.cfg.items.forEach(function (item) {
                    _.forEach(item.cells, function(cell, colName){
                        cellId = _this._getCellId(item.id, colName);
                        if (_.isObject(cell.element) && _.isString(cell.element.tag)) {
                            spec = cell.element;
                            tableCell = Polymer.dom(_this.root).querySelector('#' + cellId);
                            polyment = Polymer.dom(tableCell).appendChild(document.createElement(spec.tag));
                            if (_.isArray(spec.classes)) {
                                spec.classes.forEach(function (cls) {
                                    polyment.classList.add(cls); // Don't overwrite polymer classes.
                                });
                            }
                            if (_.isObject(spec.attributes)) {
                                _.forEach(spec.attributes, function (val, name) {
                                    if(name == 'checked') {
                                        if(val) {
                                            polyment.checked = 'checked';
                                        }
                                    } else {
                                        polyment.setAttribute(name, val);
                                    }
                                });
                            }
                            if (_.isString(spec.innerHTML)) {
                                Polymer.dom(polyment).innerHTML = spec.innerHTML;
                            }
                            if (_.isArray(spec.events)) {
                                spec.events.forEach(function (evtCfg) {
                                    if (_.isObject(evtCfg) && _.isString(evtCfg.in) && _.isString(evtCfg.out)) {
                                        polyment.addEventListener(evtCfg.in, function (evt) {
                                            eventInfo = {
                                                itemId: item.id,
                                                config: _.cloneDeep(evtCfg),
                                                targetAttributes: _this._getEventElementAttributes(evt)
                                            };
                                            _this._handleCellEvent(eventInfo);
                                        });
                                    }
                                });
                            }
                        }
                    });
                });

                this._log('_addDynamicContent done');
            }

        },

        _handleCellEvent: function(eventInfo) {
            var data = eventInfo.config.itemIdOnly ? eventInfo.itemId : eventInfo;
            this._doFire(eventInfo.config.out, data);
        },

        _getCellId: function(itemId, colName){
            return 'itm-'+itemId+'-c-'+colName;
        },

        /**
         * Return object with useful information about an event's target
         *
         * @param   {object}  evt
         * @returns {object}
         */
        _getEventElementAttributes: function(evt) {
            evt = evt || window.event;
            if(!_.isObject(evt)) return {};
            var elem = evt.target || evt.srcElement;
            return this._getElementAttributes(elem);
        },

        _getElementAttributes: function(elem) {
            var attr = {};
            if(!_.isObject(elem)) return attr;
            var attrNodeMap = Array.prototype.slice.call(elem.attributes);
            attrNodeMap.forEach(function(node){
                attr[node.name] = node.value;
            });
            attr.checked = elem.checked;
            return attr;
        },

        _toggleItemSelection: function(e) {
            var item = this.$.tableItems.itemForElement(e.target);
            this.$.itemSelector.select(item);
            this.selectedItemIDs = this._getSelectedItemIds();
            this._log('Selected IDs: ' + this.selectedItemIDs.join(', '));
        },

        _doFire: function(type, detail, options) {
            this.fire(type, detail, options);
            this._log('fired "' + type + '"');
            if(detail) {
                this._log('...with detail', detail, false);
            }
            if(options) {
                this._log('...with options', options, false);
            }
        },

        _log: function(msg, obj, withName) {
            if(this.dev) {
                withName = _.isBoolean(withName) ? withName : true;
                if(withName) {
                    msg = this.name + ': ' + msg;
                }
                console.log(msg, obj || '');
            }
        }

    });
</script>
