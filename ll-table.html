<!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="../polymer/polymer.html">

<link rel="import" href="../ll-theme/ll-theme.html">
<link rel="import" href="../ll-theme/shared-styles.html">
<link rel="import" href="../ll-firelog-behavior/ll-firelog-behavior.html">

<script type="application/javascript" src="../lodash/lodash.js"></script>


<!--
Configurable, table-less table generator with static or configuration-generated cell content, event-firing, column-wide repeating elements, and item selection.

Example:

    <ll-table></ll-table>

### Features:
- **Configuration-driven:** Generates and updates entire table from one required and one optional json object, plus optional element attributes. (See demo and /demo/sample-data.js for examples.) Dynamic insertion and deletion of individual rows is not supported.
- **Static or configuration-generated cell content:** Table cell content can be simple text or configuration-generated html elements:
 - Example - Static cell content: Any string or numeric data. (No HTML tags).
 - Example - Configuration-generated cell content with event-handling. If you need a more complete HTML element displayed within a cell, use an 'element' object in place of a string or number:
        element: {
          tag: 'span', // The type of HTML element that to generate.
          innerHTML: 'DELETE', // Optional content inside tag (currently no HTML allowed inside the main HTML tag)
          classes: [ // Optional list of classes to add to the element. Does not override the Polymer classes automatically added by Polymer.dom.
            'btn',
            'btn-primary',
            'remove-unit'
          ],
          events: [ // Optional event configuration:
            {
              in: 'click', // Event to listen for.
              out: 'remove-unit', // Event to fire.
            }
          ]
        }
- **Column-wide repeating content:** Populate an entire column of cells with the same static content or generated element by defining it in the column's configuration.
- **Column-wide item selection UI:** Any column may be designated as an item selection UI column. In this case, the entire column of cells is populated with a UI corresponding to the itemSelector.type. The "selectedItemIds" array property reflects which items are selected. Optionally, you may indicate which checkboxes are initially checked by setting the value of the 'selected' key to true in the cfg.items[..].cells objects. ('selected' is never displayed as a column value itself). Currently, only simple checkboxes are supported, but any other type of UI could be implemented.
- **Table-less markup:** Table is built with divs and css, not a table element.
- **Optional column headers:** To show column header row, include a 'label' node in at least one column definition.

@demo
-->
<dom-module id="ll-table">

  <style include="shared-styles"></style>

  <template>
    <div class="table">
      <template is="dom-if" if="[[headers]]" restamp="true">
        <div class="table-header">
          <div class="table-row">
            <template is="dom-repeat" items="[[headers]]" as="cell" restamp="true">
              <div class="table-cell">
                <template is="dom-if" if="{{cell.label}}" restamp="true">[[cell.label]]</template>
                <template is="dom-if" if="{{cell.itemSelector.checkbox}}" restamp="true"><input type="checkbox"
                                                                                                id="masterItemSelector"
                                                                                                on-change="_masterItemSelectorChanged">
                </template>
              </div>
            </template>
          </div>
        </div>
      </template>
      <div class="table-body">
        <template is="dom-repeat" id="tableItems" items="[[rows]]" as="row">
          <div class="table-row">
            <template is="dom-repeat" items="[[row.cells]]" as="cell">
              <div class="table-cell" id="[[cell.id]]">
                <template is="dom-if" if="{{cell.html}}" restamp="true">[[cell.html]]</template>
                <template is="dom-if" if="{{cell.itemSelector.checkbox}}" restamp="true"><input type="checkbox"
                                                                                                on-change="_itemSelectorChanged"
                                                                                                class="item-selector">
                </template>
              </div>
            </template>
          </div>
        </template>
        <array-selector id="itemSelector" items="{{rows}}" selected="{{selectedItems}}" multi
                        toggle></array-selector>
      </div>
    </div>
  </template>

</dom-module>

<script>

  Polymer({

    is: 'll-table',

    behaviors: [FireLogBehavior],

    properties: {

      // Optional array of column configuration objects.
      columns: {
        type: Object,
        value: function () {
          return {};
        }
      },

      // Data for each row.
      items: {
        type: Array
      },

      // IDs of selected items.
      selectedItemIds: {
        type: Array,
        readOnly: true,
        observer: '_selectedItemIdsChanged'
      },

      // If the showHeader property is set to true,
      // the column header will contain the itemIdColumnLabel property value.
      // Set element attribute 'show-item-ids'
      // When true, item IDs (if any) are displayed in their own column.
      showItemIds: {
        type: Boolean,
        value: false
      },

      // Set element attribute 'item-id-column-name'
      // Alternative label for item ID column if shown.
      itemIdColumnLabel: {
        type: String,
        value: 'id'
      },

      // Set as element attribute 'item-selector-type'
      // Valid values: 'none', 'checkbox' (more may be added later)
      itemSelectorType: {
        type: String,
        value: 'none'
      },

      // Valid values: 'left', 'right'
      // Set as element attribute 'item-selector-pos'
      // Positions the item selector column on left or right side of table.
      itemSelectorPos: {
        type: String,
        value: 'left'
      },

      // Set as element attribute 'show-header'
      // NOTE: If the itemSelectorType is != 'none',
      // header row will be shown anyway to display master selector.
      // When true, header row is displayed with column names.
      showHeader: {
        type: Boolean,
        value: false
      },

      // Objects for use in table header template.
      headers: {
        type: Array,
        value: function () {
          return [];
        },
        readOnly: true
      },

      // Is set by _setItems method when items property changes.
      // Objects for use in table body template.
      rows: {
        type: Array,
        value: function () {
          return [];
        },
        readOnly: true
      },

      _itemSelectorCellConfig: {
        type: Object,
        computed: '_computeItemSelectorCellConfig(itemSelectorType)'
      },

      _hasItemSelectors: {
        type: Boolean,
        computed: '_computeHasItemSelectors(itemSelectorType)'
      },

      // Is set by _buildHeaders to either this.columns or the first of this.items
      // in order to define the master list of columns for building headers and rows.
      _columnsDefSource: Object,

      // Set by _buildRows.
      // Keys are cell IDs, values are dynamic content definition objects.
      _dynamicContent: {
        type: Object,
        value: function () {
          return {}
        }
      },

      renderTime: {
        type: Number,
        value: 0,
        readOnly: true
      }
    },

    observers: [
      '_buildHeaders(showHeader,itemSelectorType,items,columns)',
      '_buildRows(itemSelectorType,items,columns)'
    ],

    // Element Lifecycle

    ready: function () {
      this._fireLogFire('ready');
    },

    attached: function () {
      this._fireLogFire('attached');
    },

    // Element Behavior

    _computeItemSelectorCellConfig: function (itemSelectorType) {
      var val = {};
      val[itemSelectorType] = true;
      return {
        itemSelector: val
      };
    },

    _computeHasItemSelectors: function (itemSelectorType) {
      return itemSelectorType !== 'none';
    },

    _buildHeaders: function () {

      // If there's an item selector, show the header row in order to display select all/none selector:
      if (this.itemSelectorType != 'none') {
        this.showHeader = true;
      }

      if (this.showHeader) {

        var _this = this,
            headers = [];

        if (this.itemSelectorType != 'none' && this.itemSelectorPos === 'left') {
          headers.push(this._itemSelectorCellConfig);
        }

        // Build a list of column names based on keys in first item and keys of optional columns property:
        this._columnsDefSource = !_.isEmpty(this.columns) ? this.columns : this.items[0];

        if (_.isObject(this._columnsDefSource)) {
          _.forEach(this._columnsDefSource, function (colDef, colKey) {
            if (colKey === 'id') {
              if (_this.showItemIds) {
                headers.push({label: _this.itemIdColumnLabel});
              }
            } else if (colKey != 'selected') {
              headers.push({label: _this._getColumnLabelFromColumnKey(colKey)});
            }
          });
        }

        if (this.itemSelectorType != 'none' && this.itemSelectorPos === 'right') {
          headers.push(this._itemSelectorCellConfig);
        }

        this._setHeaders(headers);

      }
    },

    _getColumnLabelFromColumnKey: function (columnKey) {
      if (_.isString(columnKey)) {
        return _.has(this.columns, columnKey + '.label') ? this.columns[columnKey].label : columnKey.replace('_', ' ');
      }
    },

    _buildRows: function () {

      this._rowBuildStartTime = new Date().getTime();

      if (!_.isArray(this.items)) {
        _this.fireLog('items set to non-array');
        return false;
      }

      this._setSelectedItemIds([]);

      if (_.isEmpty(this._columnsDefSource)) {
        this._columnsDefSource = this.items[0];
      }

      var _this = this,
          rows = [],
          row, itemId, colWideContent, cell, cellId;

      _.forEach(this.items, function (item, itmIdx) {
        itemId = item.id ? item.id : itmIdx;
        row = {
          id: itemId,
          cells: []
        };

        if (_this.itemSelectorType != 'none' && _this.itemSelectorPos === 'left') {
          row.cells.push(_this._itemSelectorCellConfig);
        }

        // Iterate thru each non-item-selector column:
        if (_.isObject(_this._columnsDefSource)) {
          _.forEach(_this._columnsDefSource, function (colDef, colKey) {
            cellId = _this._getCellId(itemId, colKey);
            cell = {id: cellId};
            if (colKey === 'id') {
              if (_this.showItemIds) {
                // Display item ID in its own column:
                cell.html = itemId;
              }
            } else if (_.has(_this, 'columns.' + colKey + '.content')) {
              // Column-wide content is defined for this column.
              colWideContent = _this.columns[colKey].content;
              if (_.isObject(colWideContent)) {
                // The column-wide content is an object defining dynamic content.
                cell.html = '';
                _this._dynamicContent[cellId] = {
                  itemId: itemId,
                  content: colWideContent
                };
              } else {
                // The column-wide content can be displayed as a string.
                cell.html = _(colWideContent).toString();
              }
            } else if (colKey != 'selected') {
              if (_.isObject(item[colKey])) {
                // Dynamic content is defined for this cell.
                cell.html = '';
                _this._dynamicContent[cellId] = {
                  itemId: itemId,
                  content: item[colKey]
                };
              } else {
                cell.html = item[colKey];
              }
            }
            if (typeof cell.html === 'string') {
              row.cells.push(cell);
              _this._lastCellId = cellId;
            }
          });
        }

        if (_this.itemSelectorType != 'none' && _this.itemSelectorPos === 'right') {
          row.cells.push(_this._itemSelectorCellConfig);
        }

        rows.push(row);

      });

      this._waitToAddDynamicContent();

      this._setRows(rows);
    },

    _waitToAddDynamicContent: function () {
      var _this = this;
      this._fireLog('Waiting for last table cell to be created...');
      this.dynamicContentWaiter = window.setInterval(function () {
        if (_this.$$('#' + _this._lastCellId) !== null) {
          _this._fireLog('Last table cell #' + _this._lastCellId + ' created.');
          _this._addDynamicContent();
        }
      }, 10);
    },

    _addDynamicContent: function () {

      window.clearInterval(this.dynamicContentWaiter);

      if (!_.isEmpty(this._dynamicContent)) {
        var _this = this;
        _.forEach(this._dynamicContent, function (cell, cellId) {
          var tableCell = Polymer.dom(_this.root).querySelector('#' + cellId);
          if (tableCell && cell.content) {
            // Presence of cell.content confirms there is dynamic content to generate.
            if (cell.content.element) {
              // This particular dynamic content is a dynamically-generated element.
              // There may be more types of dynamic content added later, hence this extra conditional block.
              var spec = cell.content.element;
              var polyment = Polymer.dom(tableCell).appendChild(document.createElement(spec.tag));
              if (polyment) {
                // Add classes to element without overwriting polymer classes:
                if (_.isArray(spec.classes)) {
                  _.forEach(spec.classes, function (cls) {
                    polyment.classList.add(cls);
                  });
                }
                // Add attributes to element if any specified:
                if (_.isObject(spec.attributes)) {
                  _.forEach(spec.attributes, function (val, name) {
                    if (name == 'checked') {
                      if (val) {
                        polyment.checked = 'checked';
                      }
                    } else {
                      polyment.setAttribute(name, val);
                    }
                  });
                }
                // Add any inner-html to element if specified:
                if (_.isString(spec.innerHTML)) {
                  Polymer.dom(polyment).innerHTML = spec.innerHTML;
                }
                // Add any event handlers to element if specified:
                if (_.isArray(spec.events)) {
                  _.forEach(spec.events, function (evtCfg) {
                    if (_.isObject(evtCfg) && _.isString(evtCfg.in) && _.isString(evtCfg.out)) {
                      polyment.addEventListener(evtCfg.in, function () {
                        _this._handleCellEvent(evtCfg.out, cell.itemId);
                      });
                    }
                  });
                }
              }
            }
          }
        });
      }

      if (this._hasItemSelectors) {
        this._initItemSelections();
      }

      this._setRenderTime((new Date().getTime() - this._rowBuildStartTime) / 1000);
      this._fireLogFire('rendered');

    },

    _handleCellEvent: function (eventOut, itemId) {
      this._fireLogFire(eventOut, itemId);
    },

    _getCellId: function (itemId, colName) {
      return 'itm-' + itemId + '-c-' + colName;
    },

    /**
     * Returns array of item ids.
     * @param {string} column
     */
    _getSelectedItemIds: function () {
      var ids = [];
      if (_.isArray(this.selectedItems)) {
        _.forEach(this.selectedItems, function (item) {
          ids.push(item.id);
        });
      }
      return ids;
    },

    _itemSelectorChanged: function (e) {
      var item = this.$.tableItems.itemForElement(e.target);
      this._toggleItemSelector(item, e.target.checked);
      this._updateMasterItemSelector();
      this._updateSelectedItemIds();
    },

    _masterItemSelectorChanged: function (e) {
      this._toggleAllItemSelectorInputs(e.target.checked);
      this._updateSelectedItemIds();
    },

    _updateMasterItemSelector: function () {
      if (this.$$('#masterItemSelector') && !_.isEmpty(this.items) && !_.isEmpty(this.selectedItems)) {
        this.$$('#masterItemSelector').checked = this.selectedItems.length === this.items.length;
      }
    },

    _updateSelectedItemIds: function () {
      this._setSelectedItemIds(this._getSelectedItemIds());
    },

    // Using observer rather than notify=true in order to use fireLog,
    // which prepends the unique name of this table instance to the custom event name.
    _selectedItemIdsChanged: function (newValue) {
      this._fireLogFire('selected-items-changed', newValue);
    },

    _initItemSelections: function () {
      var selections = [];
      _.forEach(this.items, function (item) {
        selections.push(item.selected ? true : false);
      });
      this._toggleAllItemSelectorInputs(selections);
    },

    // Toggle all item selector inputs true, false, or by array of booleans:
    _toggleAllItemSelectorInputs: function (selected) {
      var blanket;
      if (_.isBoolean(selected)) {
        blanket = true;
      } else if (_.isArray(selected)) {
        blanket = false
      } else {
        return false;
      }
      var inputs = Polymer.dom(this.root).querySelectorAll('.item-selector');
      if (_.isArray(inputs)) {
        var _this = this, sel;
        _.forEach(inputs, function (selectorEl, elIdx) {
          sel = blanket ? selected : selected[elIdx];
          _this._toggleItemSelectionInput(selectorEl, sel);
        });
        this._updateMasterItemSelector();
        this._updateSelectedItemIds();
      }
    },

    // Check or un-check checkbox or radio button and its associated itemSelector item:
    _toggleItemSelectionInput: function (inputEl, selected) {
      var selectorItem = this.$.tableItems.itemForElement(inputEl);
      this._toggleItemSelector(selectorItem, selected);
      inputEl.checked = selected;
    },

    // Select or deselect the item in the array-selector (not the checkbox element)
    _toggleItemSelector: function (item, selected) {
      this.$.itemSelector.deselect(item);
      if (selected) {
        this.$.itemSelector.select(item);
      }
    }

  });
</script>
