<!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="../polymer/polymer.html">

<link rel="import" href="../ll-theme/ll-theme.html">
<link rel="import" href="../ll-theme/shared-styles.html">

<script type="application/javascript" src="../lodash/lodash.js"></script>


<!--
Data-driven, table-less table generator with static or configuration-generated cell content, event-firing, column-wide repeating elements, and configurable item ID collection.

Example:

    <ll-table></ll-table>

### Features:
- **Configuration-driven:** Generates and updates entire table from a single json object.
- **Table-less markup:** Table is built with divs and css, not a table element.
- **Static or configuration-generated cell content:** Table cell content can be simple text or configuration-generated html elements.
- **Configuration-generated elements with event firing:** Generate any html element within a cell by setting an html tag and optional attributes, class list, inner-html, and list of event in/out pairs. The element listens for the "in" event and fires the corresponding "out" event with a data object containing the item ID, the event's configuration, and all element attributes (including a pseudo 'checked' attribute for checkboxes). Currently, only single, non-nested elements are supported.
- **Column-wide repeating content:** Populate an entire column of cells with the same static or generated element by defining it in the column's configuration.
- **Configurable item ID collection:** For columns configured with repeating custom elements (such as check-boxes), you can configure how the '_getItemIds' method generates a list of item IDs filtered by the value of a particular attribute of each element in the column. You specify the attribute and the attribute value to filter by in the column configuration. For example, you could generate one list of item IDs based on which check-boxes are checked the 'Taxable' column, and another list of item IDs based on which check-boxes are checked the 'Freaky' column.
- **Column headers are optional.**

@demo
-->
<dom-module id="ll-table">

    <style include="shared-styles"></style>

    <template>
        <div class="table">
            <template is="dom-if" if="{{cfg.colVals}}">
                <div class="table-header">
                    <div class="table-row">
                        <template is="dom-repeat" items="[[cfg.colVals]]" as="col">
                            <div class="table-cell">[[col.label]]</div>
                        </template>
                    </div>
                </div>
            </template>
            <div class="table-body">
                <template is="dom-repeat" items="[[cfg.items]]" as="item">
                    <div class="table-row">
                        <template is="dom-repeat" items="[[item.cellVals]]" as="cell">
                            <div class="table-cell" id="[[cell.id]]">[[cell.html]]</div>
                        </template>
                    </div>
                </template>
            </div>
        </div>
    </template>

</dom-module>

<script>

    Polymer({

        is: 'll-table',

        properties: {
            dev: Boolean
        },

        // Element Lifecycle

        ready: function () {
            this.fire('ll-table-ready');
        },

        attached: function() {
            this.fire('ll-table-attached');
            this._addDynamicContent();
        },

        // Element Behavior

        _setConfig: function(cfg) {
            if(!this._validateConfig(cfg)) {
                return;
            }
            this.cfg = _.cloneDeep(cfg);

            if(this.dev) {
                console.log('Raw config:', cfg);
            }

            var _this = this;

            // If content key is set in any column config,
            // copy the content config to each cell config in the column.
            var cellContent;
            this.cfg.hasHeaders = false;
            _.forEach(this.cfg.cols, function (col, colName) {
                if(_.isString(col.label)) {
                    _this.cfg.hasHeaders = true;
                }
                if (_.isObject(col.content)) {
                    _this.cfg.items.forEach(function (item, itemNum) {
                        // If the cell's config already has a value for this column,
                        // and there is a collect attribute set for an element config in the column,
                        // set that attribute with that value in the cell's attributes config:
                        cellContent = _.cloneDeep(col.content);
                        if(!_.isUndefined(item.cells[colName]) && _.isObject(cellContent.element.collect)) {
                            cellContent.element.attributes = _.assign({},cellContent.element.attributes);
                            cellContent.element.attributes[cellContent.element.collect.attribute] = item.cells[colName];
                        }
                        _this.cfg.items[itemNum].cells[colName] = cellContent;
                    });
                }
            });

            // Assign an id to each cell, converting cells with just string content to objects:
            this.cfg.items.forEach(function (item, itemNum) {
                _.forEach(item.cells, function (cell, colName) {
                    if (_.isString(cell)) {
                        _this.cfg.items[itemNum].cells[colName] = {html: cell};
                    }
                    _this.cfg.items[itemNum].cells[colName].id = _this._getCellId(item.id, colName);
                });
                _this.cfg.items[itemNum].cellVals = _.values(_this.cfg.items[itemNum].cells); // For template
            });

            if(this.cfg.hasHeaders) {
                this.cfg.colVals = _.values(this.cfg.cols); // For template
            }
            if(this.dev) {
                console.log('Converted config:', this.cfg);
            }
        },

        _validateConfig: function(cfg) {
            return _.isObject(cfg) && _.isArray(cfg.items);
        },

        _addDynamicContent: function() {

            if(this._validateConfig(this.cfg)) {
                var
                    _this = this,
                    spec,
                    tableCell,
                    cellId,
                    polyment,
                    eventInfo;

                this.cfg.items.forEach(function (item) {
                    _.forEach(item.cells, function(cell, colName){
                        cellId = _this._getCellId(item.id, colName);
                        if (_.isObject(cell.element) && _.isString(cell.element.tag)) {
                            spec = cell.element;
                            tableCell = Polymer.dom(_this.root).querySelector('#' + cellId);
                            polyment = Polymer.dom(tableCell).appendChild(document.createElement(spec.tag));
                            if (_.isArray(spec.classes)) {
                                spec.classes.forEach(function (cls) {
                                    polyment.classList.add(cls); // Don't overwrite polymer classes.
                                });
                            }
                            if (_.isObject(spec.attributes)) {
                                _.forEach(spec.attributes, function (val, name) {
                                    if(name == 'checked') {
                                        if(val) {
                                            polyment.checked = 'checked';
                                        }
                                    } else {
                                        polyment.setAttribute(name, val);
                                    }
                                });
                            }
                            if (_.isString(spec.innerHTML)) {
                                Polymer.dom(polyment).innerHTML = spec.innerHTML;
                            }
                            if (_.isArray(spec.events)) {
                                spec.events.forEach(function (evtCfg) {
                                    if (_.isObject(evtCfg) && _.isString(evtCfg.in) && _.isString(evtCfg.out)) {
                                        polyment.addEventListener(evtCfg.in, function (evt) {
                                            eventInfo = {
                                                itemId: item.id,
                                                config: _.cloneDeep(evtCfg),
                                                targetAttributes: _this._getEventElementAttributes(evt)
                                            };
                                            _this._handleCellEvent(eventInfo);
                                        });
                                    }
                                });
                            }
                        }
                    });
                });
            }

        },

        _handleCellEvent: function(eventInfo) {
            this.fire(eventInfo.config.out, eventInfo);
            if(this.dev) {
                console.log('Fired "' + eventInfo.config.out + '" with ', eventInfo);
            }
        },

        _getCellId: function(itemId, colName){
            return 'itm-'+itemId+'-c-'+colName;
        },

        /**
         * Return object with useful information about an event's target
         *
         * @param   {object}  evt
         * @returns {object}
         */
        _getEventElementAttributes: function(evt) {
            evt = evt || window.event;
            if(!_.isObject(evt)) return {};
            var elem = evt.target || evt.srcElement;
            return this._getElementAttributes(elem);
        },

        _getElementAttributes: function(elem) {
            var attr = {};
            if(!_.isObject(elem)) return attr;
            var attrNodeMap = Array.prototype.slice.call(elem.attributes);
            attrNodeMap.forEach(function(node){
                attr[node.name] = node.value;
            });
            attr.checked = elem.checked;
            return attr;
        },

        /**
         * Return array of item id strings based on the 'collect' configuration of a column.
         * @param {string} column
         */
        _getItemIds: function(column) {
            var ids = [] ;
            try {
                var collectConfig = this.cfg.cols[column].content.element.collect;
            }
            catch (e) {
                console.log('No collection configuration found for "'+column+'" column. Aborting search for ids.');
                return ids;
            }
            if(_.isObject(collectConfig)){
                var
                    _this = this,
                    cellId,
                    elemTag,
                    elem,
                    attribs;
                this.cfg.items.forEach(function(item, itemNum){
                    try {
                        elemTag = item.cells[column].element.tag;
                    }
                    catch (e) {
                        console.log('No column element config found for item ' + itemNum + '.');
                    }
                    if (_.isString(elemTag)) {
                        cellId = _this._getCellId(item.id, column);
                        elem = _this.$$('#' + cellId + ' > ' + elemTag);
                        if (_.isObject(elem)) {
                            attribs = _this._getElementAttributes(elem);
                            if (attribs[collectConfig.attribute] === collectConfig.value) {
                                ids.push(item.id);
                            }
                        }
                    }
                });
            }
            return ids;
        }

    });
</script>
