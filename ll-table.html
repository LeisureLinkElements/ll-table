<!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="../polymer/polymer.html">

<link rel="import" href="../ll-theme/ll-theme.html">
<link rel="import" href="../ll-theme/shared-styles.html">
<link rel="import" href="../ll-firelog-behavior/ll-firelog-behavior.html">

<script type="application/javascript" src="../lodash/lodash.js"></script>


<!--
Data-driven, table-less table generator with static or configuration-generated cell content, event-firing, column-wide repeating elements, and configurable item ID collection.

Example:

    <ll-table></ll-table>

### Features:
- **Configuration-driven:** Generates and updates entire table from a single json object. Dynamic insertion and deletion of individual rows is not supported.
- **Static or configuration-generated cell content:** Table cell content can be simple text or configuration-generated html elements.
- **Configuration-generated elements with event firing:** Generate any html element within a cell by setting an html tag and optional attributes, class list, inner-html, and list of event in/out pairs. The element listens for the "in" event and fires the corresponding "out" event with a data object containing the either the item ID only, or an object containing the event's configuration, and all element attributes (including a pseudo 'checked' attribute for checkboxes). Currently, only single, non-nested elements are supported.
- **Column-wide repeating content:** Populate an entire column of cells with the same static content or generated element by defining it in the column's configuration.
- **Column-wide item selection UI:** When a column definition contains an itemSelector node, the entire column of cells is populated with a UI corresponding to the itemSelector.type. The "selectedItemIds" array property reflects which items are selected. For example, if the 'assoc' column definition contains the node itemSelector: {type: 'checkbox'}, then a checkbox will appear in each cell of the column. Currently, only simple checkboxes are supported, but any other type of UI could be implemented.
- **Table-less markup:** Table is built with divs and css, not a table element.
- **Optional column headers:** To show column header row, include a 'label' node in at least one column definition.

@demo
-->
<dom-module id="ll-table">

  <style include="shared-styles"></style>

  <template>
    <div class="table">
      <template is="dom-if" if="{{hasHeaders}}" restamp="true">
        <div class="table-header">
          <div class="table-row">
            <template is="dom-repeat" items="[[colVals]]" restamp="true">
              <div class="table-cell">
                <template is="dom-if" if="{{item.label}}" restamp="true">[[item.label]]</template>
                <template is="dom-if" if="{{item.itemSelector.checkbox}}" restamp="true"><input type="checkbox"
                                                                                                id="masterItemSelector"
                                                                                                on-change="_masterItemSelectorChanged">
                </template>
              </div>
            </template>
          </div>
        </div>
      </template>
      <div class="table-body">
        <template is="dom-repeat" id="tableItems" items="[[cfg.items]]">
          <div class="table-row">
            <template is="dom-repeat" items="[[item.cellVals]]" as="cell">
              <div class="table-cell" id="[[cell.id]]">
                <template is="dom-if" if="{{cell.html}}" restamp="true">[[cell.html]]</template>
                <template is="dom-if" if="{{cell.itemSelector.checkbox}}" restamp="true"><input type="checkbox"
                                                                                                on-change="_itemSelectorChanged"
                                                                                                class="item-selector">
                </template>
              </div>
            </template>
          </div>
        </template>
        <array-selector id="itemSelector" items="{{cfg.items}}" selected="{{selectedItems}}" multi
                        toggle></array-selector>
      </div>
    </div>
  </template>

</dom-module>

<script>

  Polymer({

    is: 'll-table',

    behaviors: [FireLogBehavior],

    properties: {

      // The raw config set on element.
      config: {
        type: Object,
        observer: '_setConfig'
      },

      // The configuration generated for internal use.
      cfg: Object,

      // Array of column values for use in table header repeating column template
      colVals: {
        type: Array,
        value: function () {
          return [];
        }
      },

      isAttached: {
        type: Boolean,
        readOnly: true,
        value: false
      },

      hasItemSelectors: {
        type: Boolean,
        readOnly: true,
        value: false
      },

      // IDs of selected items.
      selectedItemIds: {
        type: Array,
        readOnly: true,
        observer: '_selectedItemIdsChanged',
        value: function () {
          return [];
        }
      },

      hasHeaders: {
        type: Boolean,
        readOnly: true,
        value: false
      },

      dynamicContentAdded: false
    },

    // Element Lifecycle

    ready: function () {
      this._fireLogFire('ready');
    },

    attached: function () {
      this._fireLogFire('attached');
      this._setIsAttached(true);
    },

    // Element Behavior

    /**
     * Sets table configuration and data.
     * @param {object} cfg
     */
    _setConfig: function (newConfig) {

      this._fireLog('_setConfig called with', newConfig);

      if (!this.isValidConfig(newConfig)) {
        this._fireLog('Invalid config!');
        return false;
      }

      this.cfg = _.cloneDeep(newConfig);

      this._setSelectedItemIds([]);

      var _this = this, cellContent, colVal;

      // If the 'content' key is set in any column config,
      // copy the content config to each cell config in the column.
      var tempColVals = [];
      _.forEach(this.cfg.cols, function (col, colName) {
        colVal = {label: ''};
        if (_.isString(col.label)) {
          _this._setHasHeaders(true);
          colVal = _.cloneDeep(col);
        }
        _.forEach(_this.cfg.items, function (item, itemNum) {
          if (_.isObject(col.content)) {
            if (col.content.itemSelector) {
              if(!_this.hasItemSelectors) {
                _this._setHasHeaders(true);
                _this._setHasItemSelectors(true);
                _this.itemSelectorColumnName = colName;
              }
              cellContent = _this._getItemSelectorCellConfig(col.content.itemSelector, item.cells[colName]);
            } else {
              cellContent = _.cloneDeep(col.content);
            }
            _this.cfg.items[itemNum].cells[colName] = cellContent;
            colVal = cellContent;
          }
        });
        tempColVals.push(colVal);
      });
      this.colVals = tempColVals;

      // Assign an id to each cell, converting cells with just string content to objects:
      _.forEach(this.cfg.items, function (item, itemNum) {
        _.forEach(item.cells, function (cell, colName) {
          if (!_.isObject(cell)) {
            _this.cfg.items[itemNum].cells[colName] = {html: _(cell).toString()};
          }
          _this.lastCellId = _this._getCellId(item.id, colName);
          _this.cfg.items[itemNum].cells[colName].id = _this.lastCellId;
        });
        _this.cfg.items[itemNum].cellVals = _.values(_this.cfg.items[itemNum].cells); // For template
      });
      this._fireLog('Converted new config to', this.cfg);

      this._waitToAddDynamicContent();

      return true;
    },

    _getItemSelectorCellConfig: function (itemSelector, isSelected) {
      var itemSelectorCfg = {
        selected: isSelected
      };
      itemSelectorCfg[itemSelector.type] = true;
      return {
        itemSelector: itemSelectorCfg
      };
    },

    _waitToAddDynamicContent: function () {
      var _this = this;
      _this._fireLog('Waiting for last table cell to be created...');
      this.dynamicContentWaiter = window.setInterval(function () {
        if (_this.isAttached && window.document.querySelector('#' + _this.lastCellId) !== null) {
          _this._fireLog('Last table cell #' + _this.lastCellId + ' created.');
          _this._addDynamicContent();
        }
      }, 20);
    },

    /**
     * Returns true if cfg is valid raw configuration.
     * @param {object} cfg
     */
    isValidConfig: function (cfg) {
      return _.isObject(cfg) && _.isObject(cfg.cols) && _.isArray(cfg.items);
    },

    /**
     * Returns true if cfg is valid configuration and has one or more items.
     * @param {object} cfg
     */
    hasItems: function (cfg) {
      return this.isValidConfig(cfg) && cfg.items.length;
    },

    _addDynamicContent: function () {

      window.clearInterval(this.dynamicContentWaiter);

      if (this.isValidConfig(this.cfg)) {
        this._fireLog('_addDynamicContent begin');
        var _this = this;
        _.forEach(this.cfg.items, function (item) {
          _this._addDynamicContentRow(item);
        });
        if(this.hasItemSelectors) {
          this._initItemSelections();
        }
        this._fireLog('_addDynamicContent end');
      }

    },

    _addDynamicContentRow: function (item) {
      var _this = this, cellId;
      if (_.isObject(item.cells)) {
        _.forEach(item.cells, function (cell, colName) {
          if (_.isObject(cell.element) && _.isString(cell.element.tag)) {
            cellId = _this._getCellId(item.id, colName);
            _this._addDynamicContentCell(cell, cellId, item.id);
          }
        });
      }
    },

    _addDynamicContentCell: function (cell, cellId, itemId) {
      var tableCell = Polymer.dom(this.root).querySelector('#' + cellId);
      if (tableCell) {
        var _this = this;
        var spec = cell.element;
        var polyment = Polymer.dom(tableCell).appendChild(document.createElement(spec.tag));
        if (polyment) {
          // Add classes to element without overwriting polymer classes:
          if (_.isArray(spec.classes)) {
            _.forEach(spec.classes, function (cls) {
              polyment.classList.add(cls);
            });
          }
          // Add attributes to element if any specified:
          if (_.isObject(spec.attributes)) {
            _.forEach(spec.attributes, function (val, name) {
              if (name == 'checked') {
                if (val) {
                  polyment.checked = 'checked';
                }
              } else {
                polyment.setAttribute(name, val);
              }
            });
          }
          // Add any inner-html to element if specified:
          if (_.isString(spec.innerHTML)) {
            Polymer.dom(polyment).innerHTML = spec.innerHTML;
          }
          // Add any event handlers to element if specified:
          if (_.isArray(spec.events)) {
            _.forEach(spec.events, function (evtCfg) {
              if (_.isObject(evtCfg) && _.isString(evtCfg.in) && _.isString(evtCfg.out)) {
                polyment.addEventListener(evtCfg.in, function (evt) {
                  var eventInfo = {
                    itemId: itemId,
                    config: _.cloneDeep(evtCfg),
                    targetAttributes: _this._getEventElementAttributes(evt)
                  };
                  _this._handleCellEvent(eventInfo);
                });
              }
            });
          }
        }
      }
    },

    _handleCellEvent: function (eventInfo) {
      var data = eventInfo.config.itemIdOnly ? eventInfo.itemId : eventInfo;
      this._fireLogFire(eventInfo.config.out, data);
    },

    _getCellId: function (itemId, colName) {
      return 'itm-' + itemId + '-c-' + colName;
    },

    /**
     * Return object with useful information about an event's target
     *
     * @param   {object}  evt
     * @returns {object}
     */
    _getEventElementAttributes: function (evt) {
      evt = evt || window.event;
      if (!_.isObject(evt)) return {};
      var elem = evt.target || evt.srcElement;
      return this._getElementAttributes(elem);
    },

    _getElementAttributes: function (elem) {
      var attr = {};
      if (!_.isObject(elem)) return attr;
      var attrNodeMap = Array.prototype.slice.call(elem.attributes);
      if (_.isArray(attrNodeMap)) {
        _.forEach(attrNodeMap, function (node) {
          attr[node.name] = node.value;
        });
      }
      attr.checked = elem.checked;
      return attr;
    },

    /**
     * Returns array of item ids.
     * @param {string} column
     */
    _getSelectedItemIds: function () {
      var ids = [];
      if (_.isArray(this.selectedItems)) {
        _.forEach(this.selectedItems, function (item) {
          ids.push(item.id);
        });
      }
      return ids;
    },

    _itemSelectorChanged: function (e) {
      var item = this.$.tableItems.itemForElement(e.target);
      this._toggleItemSelector(item, e.target.checked);
      this._updateMasterItemSelector();
      this._updateSelectedItemIds();
    },

    _masterItemSelectorChanged: function (e) {
      this._toggleAllItemSelectorInputs(e.target.checked);
      this._updateSelectedItemIds();
    },

    _updateMasterItemSelector: function () {
      if (this.cfg && _.isArray(this.cfg.items) && _.isArray(this.selectedItems)) {
        this.$$('#masterItemSelector').checked = this.selectedItems.length === this.cfg.items.length;
      }
    },

    _updateSelectedItemIds: function () {
      this._setSelectedItemIds(this._getSelectedItemIds());
    },

    // Using observer rather than notify=true in order to use fireLog,
    // which prepends the unique name of this table instance to the custom event name.
    _selectedItemIdsChanged: function (newValue) {
      this._fireLogFire('selected-items-changed', newValue);
    },

    _initItemSelections: function() {
      var selections = [], cell, _this = this;
      _.forEach(this.cfg.items, function(item) {
        if(_.isObject(item.cells[_this.itemSelectorColumnName])) {
          cell = item.cells[_this.itemSelectorColumnName];
          if(_.isBoolean(cell.itemSelector.selected)) {
            selections.push(cell.itemSelector.selected);
          }
        }
      });
      if(selections.length) {
        this._toggleAllItemSelectorInputs(selections);
      } else {
        this._toggleAllItemSelectorInputs(false);
      }
    },

    // Toggle all item selector inputs true, false, or by array of booleans:
    _toggleAllItemSelectorInputs: function (selected) {
      var blanket;
      if(_.isBoolean(selected)) {
        blanket = true;
      } else if(_.isArray(selected)) {
        blanket = false
      } else {
        return false;
      }
      var inputs = Polymer.dom(this.root).querySelectorAll('.item-selector');
      if (_.isArray(inputs)) {
        var _this = this, sel;
        _.forEach(inputs, function (selectorEl, elIdx) {
          sel = blanket ? selected : selected[elIdx];
          _this._toggleItemSelectionInput(selectorEl, sel);
        });
        this._updateMasterItemSelector();
        this._updateSelectedItemIds();
      }
    },

    // Check or un-check checkbox or radio button and its associated itemSelector item:
    _toggleItemSelectionInput: function (inputEl, selected) {
      var selectorItem = this.$.tableItems.itemForElement(inputEl);
      this._toggleItemSelector(selectorItem, selected);
      inputEl.checked = selected;
    },

    // Select or deselect the item in the array-selector (not the checkbox element)
    _toggleItemSelector: function (item, selected) {
      this.$.itemSelector.deselect(item);
      if (selected) {
        this.$.itemSelector.select(item);
      }
    }

  });
</script>
