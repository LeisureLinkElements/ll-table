<!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="../polymer/polymer.html">

<link rel="import" href="../ll-theme/ll-theme.html">
<link rel="import" href="../ll-theme/shared-styles.html">

<script type="application/javascript" src="../lodash/lodash.js"></script>


<!--
Data-driven, table-less table generator with static or configuration-generated cell content, event-firing, column-wide repeating elements, and configurable item ID collection.

Example:

    <ll-table></ll-table>

### Features:
- **Configuration-driven:** Generates and updates entire table from a single json object. Dynamic insertion and deletion of individual rows is not supported.
- **Static or configuration-generated cell content:** Table cell content can be simple text or configuration-generated html elements.
- **Configuration-generated elements with event firing:** Generate any html element within a cell by setting an html tag and optional attributes, class list, inner-html, and list of event in/out pairs. The element listens for the "in" event and fires the corresponding "out" event with a data object containing the item ID, the event's configuration, and all element attributes (including a pseudo 'checked' attribute for checkboxes). Currently, only single, non-nested elements are supported.
- **Column-wide repeating content:** Populate an entire column of cells with the same static content or generated element by defining it in the column's configuration.
- **Column-wide item selection UI:** When a column definition contains an itemSelector node, the entire column of cells is populated with a UI corresponding to the itemSelector.type. The "selectedItemIds" array property reflects which items are selected. For example, if the 'assoc' column definition contains the node itemSelector: {type: 'checkbox'}, then a checkbox will appear in each cell of the column. Optionally, you may indicate which checkboxes are initially checked by setting the value of the 'assoc' key to true in the cfg.items[..].cells objects. Currently, only simple checkboxes are supported, but any other type of UI could be implemented.
- **Table-less markup:** Table is built with divs and css, not a table element.
- **Optional column headers:** To show column header row, include a 'label' node in at least one column definition.
- **DEV mode:** Set 'dev' attribute to true to output debugging messages to console.

@demo
-->
<dom-module id="ll-table">

    <style include="shared-styles"></style>

    <template>
        <div class="table">
            <template is="dom-if" if="{{hasHeaders}}">
                <div class="table-header">
                    <div class="table-row">
                        <template is="dom-repeat" items="[[cfg.colVals]]">
                            <div class="table-cell">[[item.label]]</div>
                        </template>
                    </div>
                </div>
            </template>
            <div class="table-body">
                <template is="dom-repeat" id="tableItems" items="[[cfg.items]]">
                    <div class="table-row">
                        <template is="dom-repeat" items="[[item.cellVals]]" as="cell">
                            <div class="table-cell" id="[[cell.id]]">
                                <template is="dom-if" if="{{cell.html}}">[[cell.html]]</template>
                                <template is="dom-if" if="{{cell.itemSelector.checkbox}}"><input type="checkbox" on-change="toggleItemSelection"></template>
                            </div>
                        </template>
                    </div>
                </template>
                <array-selector id="itemSelector" items="{{cfg.items}}" selected="{{selectedItems}}" multi toggle></array-selector>
            </div>
        </div>
    </template>

</dom-module>

<script>

    Polymer({

        is: 'll-table',

        properties: {
            dev: Boolean
        },

        // Element Lifecycle

        ready: function () {
            this.fire('ll-table-ready');
        },

        attached: function() {
            this.fire('ll-table-attached');
            this._addDynamicContent();
        },

        // Element Behavior

        _setConfig: function(cfg) {
            if(!this._validateConfig(cfg)) {
                return;
            }
            this.cfg = _.cloneDeep(cfg);

            if(this.dev) {
                console.log('Raw config:', cfg);
            }

            var _this = this, cellContent, itemSelectorCfg;

            // If content key is set in any column config,
            // copy the content config to each cell config in the column.
            this.hasHeaders = false;
            _.forEach(this.cfg.cols, function (col, colName) {
                if(_.isString(col.label)) {
                    _this.hasHeaders = true;
                }
                _this.cfg.items.forEach(function (item, itemNum) {
                    if (_.isObject(col.content)) {
                        if(col.content.itemSelector) {
                            itemSelectorCfg = {};
                            itemSelectorCfg[col.content.itemSelector.type] = true;
                            cellContent = {
                                itemSelector: itemSelectorCfg
                            };
                        } else {
                            cellContent = _.cloneDeep(col.content);
                        }
                        _this.cfg.items[itemNum].cells[colName] = cellContent;
                    }
                });
            });

            if(this.hasHeaders) {
                this.cfg.colVals = _.values(this.cfg.cols); // For template
            }

            // Assign an id to each cell (for future use), converting cells with just string content to objects:
            this.cfg.items.forEach(function (item, itemNum) {
                _.forEach(item.cells, function (cell, colName) {
                    if (_.isString(cell)) {
                        _this.cfg.items[itemNum].cells[colName] = {html: cell};
                    }
                    _this.cfg.items[itemNum].cells[colName].id = _this._getCellId(item.id, colName);
                });
                _this.cfg.items[itemNum].cellVals = _.values(_this.cfg.items[itemNum].cells); // For template
            });
            if(this.dev) {
                console.log('Converted config:', this.cfg);
            }
        },

        _validateConfig: function(cfg) {
            return _.isObject(cfg) && _.isArray(cfg.items);
        },

        _addDynamicContent: function() {

            if(this._validateConfig(this.cfg)) {
                var
                    _this = this,
                    spec,
                    tableCell,
                    cellId,
                    polyment,
                    eventInfo;

                this.cfg.items.forEach(function (item) {
                    _.forEach(item.cells, function(cell, colName){
                        cellId = _this._getCellId(item.id, colName);
                        if (_.isObject(cell.element) && _.isString(cell.element.tag)) {
                            spec = cell.element;
                            tableCell = Polymer.dom(_this.root).querySelector('#' + cellId);
                            polyment = Polymer.dom(tableCell).appendChild(document.createElement(spec.tag));
                            if (_.isArray(spec.classes)) {
                                spec.classes.forEach(function (cls) {
                                    polyment.classList.add(cls); // Don't overwrite polymer classes.
                                });
                            }
                            if (_.isObject(spec.attributes)) {
                                _.forEach(spec.attributes, function (val, name) {
                                    if(name == 'checked') {
                                        if(val) {
                                            polyment.checked = 'checked';
                                        }
                                    } else {
                                        polyment.setAttribute(name, val);
                                    }
                                });
                            }
                            if (_.isString(spec.innerHTML)) {
                                Polymer.dom(polyment).innerHTML = spec.innerHTML;
                            }
                            if (_.isArray(spec.events)) {
                                spec.events.forEach(function (evtCfg) {
                                    if (_.isObject(evtCfg) && _.isString(evtCfg.in) && _.isString(evtCfg.out)) {
                                        polyment.addEventListener(evtCfg.in, function (evt) {
                                            eventInfo = {
                                                itemId: item.id,
                                                config: _.cloneDeep(evtCfg),
                                                targetAttributes: _this._getEventElementAttributes(evt)
                                            };
                                            _this._handleCellEvent(eventInfo);
                                        });
                                    }
                                });
                            }
                        }
                    });
                });
            }

        },

        _handleCellEvent: function(eventInfo) {
            this.fire(eventInfo.config.out, eventInfo);
            if(this.dev) {
                console.log('Fired "' + eventInfo.config.out + '" with ', eventInfo);
            }
        },

        _getCellId: function(itemId, colName){
            return 'itm-'+itemId+'-c-'+colName;
        },

        /**
         * Return object with useful information about an event's target
         *
         * @param   {object}  evt
         * @returns {object}
         */
        _getEventElementAttributes: function(evt) {
            evt = evt || window.event;
            if(!_.isObject(evt)) return {};
            var elem = evt.target || evt.srcElement;
            return this._getElementAttributes(elem);
        },

        _getElementAttributes: function(elem) {
            var attr = {};
            if(!_.isObject(elem)) return attr;
            var attrNodeMap = Array.prototype.slice.call(elem.attributes);
            attrNodeMap.forEach(function(node){
                attr[node.name] = node.value;
            });
            attr.checked = elem.checked;
            return attr;
        },

        toggleItemSelection: function(e) {
            var item = this.$.tableItems.itemForElement(e.target);
            this.$.itemSelector.select(item);
            if(this.dev) {
                console.log('Selected IDs: ' + this._getItemIds());
            }
        },

        /**
         * Return array of item id strings based on the 'collect' configuration of a column.
         * @param {string} column
         */
        _getItemIds: function(column) {
            var ids = [];
            if(this.selectedItems) {
                this.selectedItems.forEach(function(item) {
                    ids.push(item.id);
                });
            }
            return ids;
        }

    });
</script>
